/* Apply 2D filter convolution with separable kernels (tiling) */
fn apply_2d_row_convolution(input_image : image, output_image : image, mask : filter) -> () {
  let anchor = mask.size / 2;

  /* Applies the filter in columns */
  for x, y in @iterate(input_image, output_image) {
    let mut sum = 0.0;

    /* Checks image boundaries */
    if x >= anchor && x < input_image.width - anchor {
      for i in range(-anchor, anchor + 1) {
        sum += get_1d_filter_coeff(mask, i + anchor) * get_pixel(input_image, x + i, y);
      }

      set_pixel(output_image, x, y, sum);
    } else {
      set_pixel(output_image, x, y, get_pixel(input_image, x, y));
    }
  }
}

/* Apply 2D filter convolution with separable kernels (tiling) */
fn apply_2d_column_convolution(input_image : image, output_image : image, mask : filter) -> () {
  let anchor = mask.size / 2;

  /* Applies the filter in rows */
  for x, y in @iterate(input_image, output_image) {
    let mut sum = 0.0;

    /* Checks image boundaries */
    if y >= anchor && y < input_image.height - anchor {
      for i in range(-anchor, anchor + 1) {
        sum += get_1d_filter_coeff(mask, i + anchor) * get_pixel(input_image, x, y + i);
      }

      set_pixel(output_image, x, y, sum);
    } else {
      set_pixel(output_image, x, y, get_pixel(input_image, x, y));
    }
  }
}

/* Apply 2D filter convolution with non-separable kernels (blocks) */
fn apply_2d_block_convolution(input_image : image, output_image : image, mask : filter) -> () {
  let anchor = mask.size / 2;

  /* Applies the filter in blocks */
  for x, y in @iterate(input_image, output_image) {
    let mut sum = 0.0;

    /* Checks image boundaries */
    if x >= anchor && x < input_image.width - anchor && y >= anchor && y < input_image.height - anchor {
      for i in range(-anchor, anchor + 1) {
        for j in range(-anchor, anchor + 1) {
          sum += get_2d_filter_coeff(mask, i + anchor, j + anchor) * get_pixel(input_image, x + i, y + j);
        }
      }

      set_pixel(output_image, x, y, sum);
    } else {
      set_pixel(output_image, x, y, get_pixel(input_image, x, y));
    }
  }
}

/* Gaussian filter */
fn gaussian_blur(input_image : image, output_image : image) -> () {
  /* Generates the separable Gaussian kernel based on the
     OpenCV source code */
  let bmask_xy = alloc_cpu(5 * 5 * sizeof[f64]());
  let bmask_x = alloc_cpu(5 * sizeof[f64]());
  let bmask_y = alloc_cpu(5 * sizeof[f64]());

  let mask_xy = bmask_xy.data as &mut[f64];
  let mask_x = bmask_x.data as &mut[f64];
  let mask_y = bmask_y.data as &mut[f64];
  let mut sum_x = 0.0;
  let mut sum_y = 0.0;
  let anchor = 2.0;
  let pi = 3.14159;
  let sigma = 1.1;
  let prod = 1.0 / (2.0 * pi * sigma * sigma);
  let denom = 2.0 * sigma * sigma;
  let use_tiled = true;

  for i in range(0, 5) {
    let x = (i as f64) - anchor;

    for j in range(0, 5) {
      let y = (j as f64) - anchor;

      mask_xy(j * 5 + i) = prod * exp(-((x * x + y * y) / denom));
    }

    mask_x(i) = exp(-((x * x) / denom));
    mask_y(i) = exp(-((x * x) / denom));
    sum_x += mask_x(i);
    sum_y += mask_y(i);
  }

  sum_x = 1.0 / sum_x;
  sum_y = 1.0 / sum_y;

  for i in range(0, 5) {
    mask_x(i) *= sum_x;
    mask_y(i) *= sum_y;
  }

  /* Applies the separable kernel in rows and columns */
  if use_tiled {
    let row_filter = filter_5x1(bmask_x);
    let column_filter = filter_5x1(bmask_y);

    apply_2d_row_convolution(input_image, output_image, row_filter);
    apply_2d_column_convolution(input_image, output_image, column_filter);

    release_filter(row_filter);
    release_filter(column_filter);
  /* Applies the not separable kernel in blocks */
  } else {
    let block_filter = filter_5x5(bmask_xy);
    apply_2d_block_convolution(input_image, output_image, block_filter);
    release_filter(block_filter);
  }

  release(bmask_xy);
  release(bmask_x);
  release(bmask_y);
}
