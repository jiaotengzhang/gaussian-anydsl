struct image {
  buffer : Buffer,
  device_data : Buffer,
  width : i32,
  height : i32
}

struct filter {
  buffer : Buffer,
  size: i32
}

fn range(mut min : i32, max : i32, body : fn(i32) -> ()) -> () {
  while min < max {
    body(min);
    min++;
  }
}

fn exp(a : f64) -> f64 {
  cuda_intrinsics.exp(a)
}

/* Sets image pixel at (x, y) coordinates */
fn set_pixel(img : image, x : i32, y : i32, value : f64) -> () {
  bitcast[&mut[1][f64]](img.device_data.data)(y * img.width + x) = value
}

/* Gets image pixel at (x, y) coordinates */
fn get_pixel(img : image, x : i32, y : i32) -> f64 {
  bitcast[&[1][f64]](img.device_data.data)(y * img.width + x)
}

/* Gets 1D filter coefficient at i index */
fn get_1d_filter_coeff(filt : filter, i : i32) -> f64 {
  bitcast[&[1][f64]](filt.buffer.data)(i)
}

/* Gets 2D filter coefficient at (i, j) index */
fn get_2d_filter_coeff(filt : filter, i : i32, j : i32) -> f64 {
  bitcast[&[1][f64]](filt.buffer.data)(j * filt.size + i)
}

fn iterate(input_image : image, output_image : image, body: fn(i32, i32) -> ()) -> () {
  let accelerator = cuda_accelerator(0);
  let grid = (image.width, image.height, 1);
  let block = (128, 1, 1);

  with accelerator.exec(grid, block) @{
    let gid_x = accelerator.bidx() * accelerator.bdimx() + accelerator.tidx();
    let gid_y = accelerator.bidy() * accelerator.bdimy() + accelerator.tidy();

    if gid_x < image.width && gid_y < image.height {
      body(gid_x, gid_y);
    }
  }
}

/* Generates a 5x1 filter data structure given its coefficients */
fn filter_5x1(mask : [f64 * 5]) -> filter {
  let accelerator = cuda_accelerator(0);

  /* Allocates the filter data structure for a 5x1 filter */
  let result = filter {
    buffer: accelerator.alloc(5 * sizeof[f64]()),
    size: 5
  };

  /* Stores the coefficients in the filter data */
  for i in range(0, 5) {
    bitcast[&mut[1][f64]](result.buffer.data)(i) = mask(i);
  }

  result
}

/* Generates a 5x5 filter data structure given its coefficients */
fn filter_5x5(mask : [[f64 * 5] * 5]) -> filter {
  let accelerator = cuda_accelerator(0);

  /* Allocates the filter data structure for a 5x1 filter */
  let result = filter {
    buffer: accelerator.alloc(5 * 5 * sizeof[f64]()),
    size: 5 * 5
  };

  /* Stores the coefficients in the filter data */
  for j in range(0, 5) {
    for i in range(0, 5) {
      bitcast[&mut[1][f64]](result.buffer.data)(j * 5 + i) = mask(i)(j);
    }
  }

  result
}
